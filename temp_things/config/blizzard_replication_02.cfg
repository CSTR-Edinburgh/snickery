environment =  'mac' #  'dice' # 'mac' 


## ---- tools ----

if environment == 'mac':
    openfst_bindir = '/Users/owatts/tool/bin'    
elif environment == 'dice':
    openfst_bindir = '/afs/inf.ed.ac.uk/user/o/owatts/sim2/oliver/tool/bin/'

## outputs will be put in subdirectories under here:
workdir = '/afs/inf.ed.ac.uk/group/cstr/projects/simple4all_2/oliver/slm_data_work/work/fls_bliz_replic_pitch_sync'



## ----------- training data locations ---------

#TOPDIR='/afs/inf.ed.ac.uk/group/cstr/projects/simple4all_2/oliver/slm_data_work/fls_hybrid/feat_29'
TOPDIR='/afs/inf.ed.ac.uk/group/cstr/projects/nst/oliver/hybrid_work/data/fls_data/'

## original train data features, for join cost:
join_datadirs = [TOPDIR + '/pitch_sync/']

## this is the training data as regenerated by LSTM trained on it (for target cost):
target_datadirs = ['/afs/inf.ed.ac.uk/group/cstr/projects/blizzard_entries/blizzard2017/hybrid_voice/data/predicted_params/train/']
 
### 48k, mono, 16-bit wav-headered audio:
wav_datadir = '/afs/inf.ed.ac.uk/group/cstr/projects/blizzard_entries/blizzard2017/data/segmented/wav/'

### Reaper pitchmarks:
#pm_datadir = '/afs/inf.ed.ac.uk/group/cstr/projects/blizzard_entries/blizzard2017/reaper_pm/world_reaper/pm/'
pm_datadir = TOPDIR + '/world_reaper/pm/'


label_datadir = '/afs/inf.ed.ac.uk/group/cstr/projects/blizzard_entries/blizzard2017/parametric_synthesis/benchmark-merlin-data/labels/combilex/label_state_align/'



## ----------- synthesis data locations ---------


test_lab_dir = '/afs/inf.ed.ac.uk/group/cstr/projects/blizzard_entries/blizzard2017/parametric_synthesis/merlin/egs/fls_blizzard_2017/s1/experiments/fls_blizzard_full/test_synthesis/gen-lab-final/'
test_data_dirs = ['/afs/inf.ed.ac.uk/group/cstr/projects/blizzard_entries/blizzard2017/hybrid_voice/data/predicted_params/final_test/']
## this can be any filename substring, selecting a portion of the data ('hvd') or a single file ('AMidsummerNightsDream_001_016')
test_patterns = ['PirateAdventures']




## ------- data -----


## this can be an int to take the first n utterances, else a string to match
## the names of some utterances. 0 means take all.
n_train_utts = 119 # 'AMidsummerNightsDream_001' #  14 # 23 #  23

## labels
lab_extension = 'lab'

## HTS style:
quinphone_regex = '([^~]+)~([^-]+)-([^\+]+)\+([^\=]+)\=([^:]+)'
## Ossian style
#quinphone_regex = '/1:([^/]+)/2:([^/]+)/3:([^/]+)/4:([^/]+)/5:([^/]+)' 


stream_list1 = ['mgc', 'bap', 'lf0']  ## these are names of subdirs and extensions. 
                                    ## Composition will happen in the order of this list.

datadims1 = {}
datadims1['bap'] = 25   
datadims1['mgc'] = 60
datadims1['lf0'] = 1
datadims1['vuv'] = 1



stream_list_target = stream_list1
stream_list_join = ['energy', 'mfcc12', 'f0']

datadims_target = datadims1
datadims_join = {'energy': 1, 'mfcc12': 12, 'f0': 1}


frameshift_ms = 5
sample_rate = 48000


## A peculiarity of the Blizzard regenerated data is that the end silences are stripped, replace them with zeros: 
untrim_silence_join_speech = False
untrim_silence_target_speech = True

### --- stream-level weights

#target_stream_weights = [1.0,0.0,1.0]
#join_stream_weights = [1.0,1.0,1.0]


## optimised for stream balance on 1 pirate utterance
join_stream_weights = [13.668097769038635, 1.0, 26.71320456975962]
target_stream_weights = [1.0, 1.3747733503819828, 7.962990507100127]

### ----- standardisation and weighting -------

## First, data is standardised by the "train" script (per stream rather than 
## per coefficient) and stored to disk. 

standardise_target_data = True
standardise_join_data = True 
                 
## The "synth" script loads the standardised data and applies the following weights. 
## These weights are applied to the data before distances are computed, which is 
## equivalent to weighting the differences before squaring, but slightly more efficient
## and allows us to use KD tree implementations with only simple Euclidean distance.
## The weights used here would be squared if they were to be applied to the squared 
## difference term (as in the more standard formulation of weighted Euclidean distance)
## with the same effect.

weight_target_data = True
weight_join_data = True

#feature_weights_target = [2.0] + [10.0]*12 + [0.0]*47 
#feature_weights_target += [0.0] * datadims_target['bap']
#feature_weights_target += [2.0]                            ## f0
#feature_weights_target += [0.0]                           ## vuv


feature_weights_target = [1.0] * sum(datadims_target.values())


#feature_weights_join = [1.0] + [1.0/12]*12 + [1.0] + [1.0]  ## energy, mfccs, F0, VUV

feature_weights_join = [1.0] * 15
#feature_weights_join = [ 3.8983963 ]  + [1.0] * 12 +          [4.32854156] + [0.0]


#feature_weights_join = [ 15.197493691400247 ]  + [1.0] * 12 +          [18.736272015034281] + [0.0]


#feature_weights_join = [5.66454952] + [1.0/12]*12 + [6.9835555 ] + [0.0] 



feature_names_target = ['mcc%s'%(i) for i in xrange(datadims_target['mgc'])]
feature_names_target += ['bap%s'%(i) for i in xrange(datadims_target['bap'])]
feature_names_target += ['f0']                            ## f0
feature_names_target += ['vuv']                            ## vuv


feature_names_join = ['energy']
feature_names_join += ['mfcc%s'%(i+1) for i in range(12)]
feature_names_join = ['f0']



kdt_implementation = 'stashable' #  'sklearn' # 'scipy' # 'sklearn'
target_metric = 'euclidean' # 'weighted_euclidean'
                                       
                   

### ----- join data -----

### This says to dump some data which can be used for learning a join cost with active learning
dump_join_data = False
join_cost_halfwidth = 5   ## consider this number of frames on each side of the join


                                    

## -------- synthesis --------

#synth_topdir = workdir + '/synthesis/'

## only for Blizzard replication -- substitute B_150 etc for pau:
suppress_weird_festival_pauses = True

n_test_utts = 100 # 10

debug_with_adjacent_frames = False # True

hold_waves_in_memory = False # True

n_candidates = 30 # 50 # 10 

join_cost_type = 'natural2' 

## overall scaling factor
join_cost_weight = 3.0

preselection_method =   'quinphone' # 'acoustic' #

## Waveforms are overlapped-and-added using a hanning window of length taper_length*2 samples
taper_length = 300

## Print some info for debugging synthesis:
get_selection_info = True




